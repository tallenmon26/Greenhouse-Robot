import cv2
import depthai as dai
import numpy as np
import time
import threading
import serial # <-- NEW: Import the serial library

# --- NEW: Setup Serial Connection to ESP32 ---
SERIAL_PORT = '/dev/ttyACM0' # Make sure this matches your Pi's port
BAUD_RATE = 115200
try:
    esp32 = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)
    time.sleep(2) # Wait for connection
except serial.SerialException as e:
    print(f"Warning: Could not connect to ESP32: {e}")
    esp32 = None

FPS_LIMIT = 30  # Cap FPS to reduce processing load
frame_lock = threading.Lock()
should_quit = False

# --- TUNING PARAMETERS ---
SAFE_DISTANCE_MM = 600
BLACK_THRESHOLD = 60
MIN_CONTOUR_AREA = 500

# --- 1. OBSTACLE ZONE (Red Box - Look Ahead/Forward) ---
# Upper-middle area - catches obstacles in the forward direction
OBST_ROI_X = 220  # Centered horizontally (for 640 width)
OBST_ROI_Y = 60   # Upper area - forward line of sight at ~45Â°
OBST_ROI_W = 200
OBST_ROI_H = 140

# --- 2. LINE ZONE (Yellow Box - Look Down at Ground) ---
# Lower area - focuses on ground line directly below robot
LINE_ROI_W = 200        
LINE_ROI_X = (640 - LINE_ROI_W) // 2  # Centered (320)
LINE_ROI_Y = 320        # Lower area - ground level
LINE_ROI_H = 100

# Pipeline setup
pipeline = dai.Pipeline()

# Mono Cameras
left = pipeline.create(dai.node.Camera).build(dai.CameraBoardSocket.CAM_B)
right = pipeline.create(dai.node.Camera).build(dai.CameraBoardSocket.CAM_C)

# RGB Camera
rgb_cam = pipeline.create(dai.node.Camera).build(dai.CameraBoardSocket.CAM_A)
rgb_out = rgb_cam.requestOutput((640, 480), dai.ImgFrame.Type.BGR888p)

# Stereo Depth
stereo = pipeline.create(dai.node.StereoDepth)
stereo.setLeftRightCheck(True)
stereo.setSubpixel(False)

left.requestOutput((640, 400)).link(stereo.left)
right.requestOutput((640, 400)).link(stereo.right)

# Increase queue sizes to buffer frames
depth_q = stereo.depth.createOutputQueue(maxSize=4, blocking=False)
rgb_q = rgb_out.createOutputQueue(maxSize=4, blocking=False)

print("Running... Press 'q' to quit.")

# Main loop
with pipeline:
    pipeline.start()
    
    last_frame_time = time.time()
    frame_count = 0

    while pipeline.isRunning() and not should_quit:
        # FPS limiting - skip if we're going too fast
        current_time = time.time()
        if current_time - last_frame_time < (1.0 / FPS_LIMIT):
            time.sleep(0.001)
            continue
        last_frame_time = current_time

        in_depth = depth_q.tryGet()
        in_rgb = rgb_q.tryGet()

        if in_depth is None or in_rgb is None:
            continue  # Skip the sleep, just continue

        depth_frame = in_depth.getFrame()
        rgb_frame = in_rgb.getCvFrame()
        
        # --- 1. OBSTACLE DETECTION (Red Box) ---
        obst_roi = depth_frame[OBST_ROI_Y:OBST_ROI_Y+OBST_ROI_H, 
                               OBST_ROI_X:OBST_ROI_X+OBST_ROI_W]
        valid_depths = obst_roi[obst_roi > 0]
        distance = int(np.median(valid_depths)) if valid_depths.size else 9999

        # Draw Obstacle Box
        color_status = (0, 255, 0)
        if 0 < distance < SAFE_DISTANCE_MM:
            color_status = (0, 0, 255)
        cv2.rectangle(rgb_frame, (OBST_ROI_X, OBST_ROI_Y), 
                      (OBST_ROI_X+OBST_ROI_W, OBST_ROI_Y+OBST_ROI_H), color_status, 2)
        cv2.putText(rgb_frame, f"Dist: {distance}mm", (OBST_ROI_X, OBST_ROI_Y-10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, color_status, 2)

        # --- 2. LINE DETECTION (Yellow Box) ---
        # Crop to the NEW narrower ROI
        line_roi_slice = rgb_frame[LINE_ROI_Y:LINE_ROI_Y+LINE_ROI_H, 
                                   LINE_ROI_X:LINE_ROI_X+LINE_ROI_W]
        
        gray_roi = cv2.cvtColor(line_roi_slice, cv2.COLOR_BGR2GRAY)
        _, thresh = cv2.threshold(gray_roi, BLACK_THRESHOLD, 255, cv2.THRESH_BINARY_INV)
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        line_detected = False
        error = 0
        
        # Center of the SEARCH BOX, not the whole screen
        box_center_x = LINE_ROI_W // 2 

        # Draw the Yellow Search Box
        cv2.rectangle(rgb_frame, (LINE_ROI_X, LINE_ROI_Y), 
                      (LINE_ROI_X+LINE_ROI_W, LINE_ROI_Y+LINE_ROI_H), (0, 255, 255), 2)

        if contours:
            c = max(contours, key=cv2.contourArea)
            if cv2.contourArea(c) > MIN_CONTOUR_AREA:
                M = cv2.moments(c)
                if M["m00"] != 0:
                    cx_local = int(M["m10"] / M["m00"])
                    cy_local = int(M["m01"] / M["m00"])
                    
                    # Error is relative to the center of the yellow box
                    error = cx_local - box_center_x
                    line_detected = True
                    
                    # Convert local box coordinates to global screen coordinates for drawing
                    cx_global = cx_local + LINE_ROI_X
                    cy_global = cy_local + LINE_ROI_Y
                    
                    # Draw Line
                    c_shifted = c + [LINE_ROI_X, LINE_ROI_Y]
                    cv2.drawContours(rgb_frame, [c_shifted], -1, (0, 255, 0), 2)
                    cv2.circle(rgb_frame, (cx_global, cy_global), 5, (0, 0, 255), -1)

        # --- 3. LOGIC ---
        command_to_send = b"STOP\n" # Default to stopping safely

        if 0 < distance < SAFE_DISTANCE_MM:
            status = "STOP! OBSTACLE"
            color = (0, 0, 255)
            command_to_send = b"STOP\n"
            
        elif line_detected:
            if error < -15:
                status = "Turn LEFT"
                color = (0, 255, 0)
                command_to_send = b"LEFT\n"
            elif error > 15:
                status = "Turn RIGHT"
                color = (0, 255, 0)
                command_to_send = b"RIGHT\n"
            else:
                status = "FORWARD"
                color = (0, 255, 0)
                command_to_send = b"FORWARD\n"
        else:
            status = "Searching..."
            color = (255, 100, 0)
            command_to_send = b"STOP\n" # Stop moving if we lose the line completely

        # Send the finalized command to the ESP32
        if esp32:
            esp32.write(command_to_send)

        cv2.putText(rgb_frame, status, (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, color, 3)
        cv2.imshow("Robot View", rgb_frame)

        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            should_quit = True

cv2.destroyAllWindows()
if esp32:
    print("\nShutting down... sending final STOP command to motors.")
    esp32.write(b"STOP\n")
    time.sleep(0.1) # Give the serial port a split second to flush the data
    esp32.close()
    print("Motors stopped. Serial connection closed.")
